---
layout: post
title: Mysql 索引
subtitle: 
categories: Mysql
tags: [Mysql]
---



## 1. mysql中的io

数据的存储有几种主要的形式:内存、磁盘、缓存，这三者的读写效率:缓存 >> 内存 >>磁盘，其中内存的io效率比随机的磁盘io效率高十万倍以上。



在mysql中，所有的数据最终都会持久化到磁盘中保存，但是频繁的发生随机的磁盘io，会大大降低mysql的查询效率，所以mysql应该尽量减少对磁盘的访问，让查询尽量直接访问内存甚至缓存。



操作系统有关于这一块的优化，采用预读机制，将一次磁盘io访问的数据附近的一块磁盘数据一起加载到内存，组织成一个数据页，这是因为根据经验，一块数据被访问了，那么和它靠近的数据很有可能很快就会被访问。



## 2. 索引的目的

如果我们要在字典里查找mysql这个词，可以先在目录里查到'm'开头的词的分类，然后找到'y'开头的下一级分类的页码，最后从这个页码开始一个一个的找到剩下的'sql'，试想如果没有这个目录，我们是不是要把整个字典翻一遍？如果我要把所有'z'开头的单词都找出来，那么这个工作量是不是几乎不可完成?



索引的目的在于提高检索的效率。生活中随处可见索引的例子，词典和书的目录、火车的车次表、电商网站的商品分类等等，它们的目的和原理都是一致的，通过索引不断缩小查找的范围，把随机的查找变成顺序的查找，提高查询的效率。



数据库的场景更加的复杂，它不仅仅需要"="查询，还需要">"、<"、"between"、"like"等更加复杂的查询场景，那么数据库该如何设计索引的结构来满足这些复杂的场景呢？



关于搜索有个很常用的数据结构:二叉搜索树，它的性质是左子树的值永远小于右子树的值，它的查询效率是lgN，非常高校，而它的数据倾斜的问题也可以通过树的旋转来解决，但是对于数据库而言，简单的二叉搜索树是不适用的。



假设数据库中存有一千万条数据，用二叉搜索树建立索引的话，如果数据的区分度很高，那么树的高度将会非常高，而索引是以文件的形式存储在磁盘中的，每一层树的搜索，都需要访问一次磁盘并将索引内容加载到内存，这样一来二叉搜索树的高度将会造成非常大数量级的磁盘访问操作，会大大降低查找的效率。



## 3. 索引的原理

### 3.1 B+树

前面介绍了一些io的效率对比以及生活中的索引例子，分析了二叉搜索树为什么不适合mysql的场景，最终是为了引出B+树的结构，从中我也明白了计算机演进的一个规律:任何的数据结构都不是凭空产生的，一定是为了解决某些问题在特定的背景下产生的。



通过二叉搜索树我们大概已经知道了什么样的数据结构更加适合mysql的索引结构。索引的查询必须把对磁盘的访问控制在一个非常小的量级，只需要几次磁盘的访问，就能在千万甚至亿的量级里找到需要的数据。



在这种需求背景下，B+树应运而生，B+树是一种高度可控的多路搜索树，其结构如下图:

![](https://jiang523.github.io//images/2022-08-08-mysql-index/image-20220824114339897.png)



首先介绍几个mysql中B+树的性质:

1. 只有叶子结点才会保存真实的索引数据，非叶子结点只存储虚拟的索引项，非叶子结点的数据并不真正存在于数据表中。

2. 所有叶子结点都已经进行了排序，并已经通过指针建立成了链表，这样一来范围查询变得更加高效。

3. 联合索引会根据索引建立的字段顺序排序，如以(name,age)建立索引，那叶子结点的顺序就是先根据name排序再根据age排序

   

下面来分析一下B+树的查找过程，假设我们要查找60这个数据项，查找的过程如下:

1. 将磁盘块1加载到内存，通过比较60 > 35,定位到P3指针指向的地址
2. 将磁盘块4加载到内存，通过比较60 < 65,定位到P1指针指向的地址
3. 将磁盘块9加载到内存，通过二分法在数据页中找到数据项为60的数据

查询结束，三层的B+树一次查询最坏的情况(所有数据内存中都不存在)下发生了三次磁盘io，而三层的B+树可以表示上百万的数据，如果没有索引，则需要进行百万次的io，性能的差距是非常巨大的。



通过上面的分析，可以得出一个结论，mysql查询过程中，磁盘io的次数取决于B+树的高度H，假设一张表的数据量是N，一个数据页保存的数据项数量是m，则可以得到一个关系:
$$
H=\log_{m+1}N
$$
在数据量N一定的情况下，m越大H越小，而m = 数据页大小 / 数据项大小，数据页的大小是一定的，所以数据项越小m越大，B+树的高度越小，发生的磁盘io次数越少。



这带给我们一些索引运用时的一些启示，建立索引时，尽量选择内存占用少的字段，如用int代替bigint。这也解释了为什么B+树的非叶子结点不存储真实数据项—— 尽量减小数据项的大小。



### 3.2 聚簇索引

InnoDB根据索引的类型是不是主键分为主键索引和非主键索引，也称为聚簇索引和辅助索引。在索引的结构层面二者的区别在于，聚簇索引的叶子结点存储的是一行数据记录，而辅助索引存储的是该索引字段的数据项对应的主键。



因此在用辅助索引查询时，需要两次B+树的搜索，一次通过辅助索引找到对应的主键，再通过聚簇索引找到对应的数据记录，这个过程称为回表。



很明显，回表会降低查询的效率，因此在写sql时，需要尽可能的去避免回表。例如有一张学生表,以name字段建立了索引

```sql
create table student (
	id int primary key ,
	name varchar(255) not null,
	age int not null,
  index(name)
)
```



现在要根据学生姓名去查询，可以这么写

```sql
select * from student where name = '张三'
```

那么这条语句就需要回表去查询age字段，在我们不需要age字段时，可以用以下语句代替

```sql
select id,name from student where name = '张三'
```

这样的话，因为name的索引树中的叶子结点已经存储了id和name字段，就不用再回表查询age了，节省了一次B+树的搜索时间，这种方式也叫做索引下推。



### 3.3 索引的维护

